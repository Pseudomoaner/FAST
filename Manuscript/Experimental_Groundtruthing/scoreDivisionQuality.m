function [TP,FP,TN,FN] = scoreDivisionQuality(autoTracks,manualTracks)
%SCOREDIVISIONQUALITY compares the tracks generated by the FAST tracking
%algorithm to a ground truth either generated by from the SPR simulations
%directly, or compiled from manual validation.
% 
%Note that autoTracks and manualTracks are presumed to be in the
%'procTracks' data format.
%
%   INPUTS:
%       -autoTracks: The tracks generated by FAST  
%       -manualTracks: The ground truth tracks
%   
%   OUTPUTS:
%       -TP: The number of true positives (correctly assigned 
%       mother-daughter links)
%       -FP: The number of false positives (incorrectly assigned links)
%       -TN: The number of true negatives (correctly assigned trajectory
%       end points)
%       -FN: The number of false negatives (prematurely terminated lineages)
%
%   Author: Oliver J. Meacock, 2023

TP = 0;
FP = 0;
TN = 0;
FN = 0;

%Thresholds used to decide whether cells are equivalent between manual and automatic tracks
distThresh = 0.5;
timeThresh = 2;

%Go through each track in the manually curated dataset
for i = 1:size(manualTracks,2)
    %Begin by finding this cell in the automated dataset
    posM = [manualTracks(i).x(end),manualTracks(i).y(end)];
    tM = manualTracks(i).times(end);
    
    Mfound = false; %Will be set to true if this cell is found
    
    %Search for a track in the auto tracks that resembles this cell at
    %its endpoint...
    for j = 1:size(autoTracks,2)
        if autoTracks(j).times(end) < tM + timeThresh && autoTracks(j).times(end) > tM - timeThresh
            posMcand = [autoTracks(j).x(end),autoTracks(j).y(end)];
            posMdiff = sqrt(sum((posMcand-posM).^2));
            
            %The proposed mother must be within a given proximity
            %of the target...
            if posMdiff < distThresh
                Mfound = true;
                
                %Check the true number of assigned daughters
                noD = sum([~isempty(manualTracks(i).D1),~isempty(manualTracks(i).D2)]);
                noDcand = sum([~isempty(autoTracks(j).D1),~isempty(autoTracks(j).D2)]);
                
                if noD == 0 %No daughters
                    TN = TN + 2 - noDcand; %Note that this effectively treats every track at the end of the timelapse as a cell with two missing daughters.
                    FP = FP + noDcand;
                elseif noD == 1 && noDcand == 0
                    TN = TN + 1;
                    FN = FN + 1; %Automated system missed a daughter
                elseif noD == 1 && noDcand == 1
                    TN = TN + 1;
                elseif noD == 1 && noDcand == 2
                    FP = FP + 1; %Automated system found a daughter where there shouldn't be one
                end                
                
                %Find positions of manually-assigned and automatically
                %assigned daughters
                if ~isempty(manualTracks(i).D1)
                    posD1 = [manualTracks(manualTracks(i).D1).x(1),manualTracks(manualTracks(i).D1).y(1)];
                    tD1 = manualTracks(manualTracks(i).D1).times(1);
                else
                    posD1 = [inf,inf];
                    tD1 = inf;
                end
                
                if ~isempty(manualTracks(i).D2)
                    posD2 = [manualTracks(manualTracks(i).D2).x(1),manualTracks(manualTracks(i).D2).y(1)];
                    tD2 = manualTracks(manualTracks(i).D2).times(1);
                else
                    posD2 = [inf,inf];
                    tD2 = inf;
                end
                
                if ~isempty(autoTracks(j).D1)
                    posD1cand = [autoTracks(autoTracks(j).D1).x(1),autoTracks(autoTracks(j).D1).y(1)];
                    tD1cand = autoTracks(autoTracks(j).D1).times(1);
                else
                    posD1cand = [inf,inf];
                    tD1cand = inf;
                end
                
                if ~isempty(autoTracks(j).D2)
                    posD2cand = [autoTracks(autoTracks(j).D2).x(1),autoTracks(autoTracks(j).D2).y(1)];
                    tD2cand = autoTracks(autoTracks(j).D2).times(1);
                else
                    posD2cand = [inf,inf];
                    tD2cand = inf;
                end
                
                %Do pairwise comparisons (could calculate distance matrix,
                %but this seems clearer)
                dist11 = sqrt(sum((posD1cand-posD1).^2));
                dist21 = sqrt(sum((posD2cand-posD1).^2));
                dist12 = sqrt(sum((posD1cand-posD2).^2));
                dist22 = sqrt(sum((posD2cand-posD2).^2));
                tDiff11 = abs(tD1cand-tD1);
                tDiff21 = abs(tD2cand-tD1);
                tDiff12 = abs(tD1cand-tD2);
                tDiff22 = abs(tD2cand-tD2);
                
                candPairs = and([dist11,dist21,dist12,dist22] < distThresh,[tDiff11,tDiff21,tDiff12,tDiff22] < timeThresh);
                
                if sum(candPairs(1:2)) == 2 || sum(candPairs(3:4)) == 2 %implies both auto-generated daughters are pointing to the same place
                    TP = TP + 1;
                    if noD == 2 %Alternative false-positive case, a single true daughter, dealt with above. Don't want to double count.
                        FP = FP + 1;
                    end
                else
                    TP = TP + sum(candPairs);
                    FP = FP + (noD-sum(candPairs)); %noD is expected number of daughters, sum(candPairs) is the actual number found, any difference must be due to mis-assignment
                end
                break
            end
        end
    end
    if ~Mfound %If the mother was never found, mark as two false negatives (Likely a division detection failure at the tracking stage)
        FN = FN + 2;
    end    
end