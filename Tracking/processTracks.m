function [procTracks,fromMappings,toMappings] = processTracks(rawTracks,fromMappings,toMappings,trackSettings,trackTimes,debugSet)
%PROCESSTRACKS performs post-processing on the tracks generated by the
%earlier stages of the FAST tracking pipeline. Tasks performed: velocity
%calculation (based on positions), removal of short tracks, association of
%sampling timepoints with tracks.
%
%   INPUTS:
%       -rawTracks: initial track format. Should come direct from the
%       'extractDataTrack' function
%       -fromMappings: mapping from the 'track' representation of the data 
%       (i.e. feature values associated with specific tracks) back to the 
%       'slice' representation (i.e. feature values associated with unknown
%       tracks but defined timepoints). 
%       -toMappings: mapping from the original 'slice' representation of the
%       data to the 'track' representation of the data. For more details, see the
%       'extractDataTrack' function. 
%       -trackSettings: settings for tracking, defined within the
%       diffusionTracker GUI
%       -trackTimes: times of track samples, in units of frames
%       -debugSet: whether debugging is currently active
%
%   OUTPUTS:
%       -procTracks: tracks with new fields (vmag, theta, times, length, start,
%       end) defined and short tracks removed
%       -fromMappings: fromMappings with short tracks removed
%       -toMappings: toMappings with short tracks removed
%
%   Author: Oliver J. Meacock, (c) 2019

debugprogressbar([0.8;0;0],debugSet)

trackDataNames = fieldnames(rawTracks);

%Remove all tracks that are shorter than the specified threshold
lengthDist = zeros(size(rawTracks.(trackDataNames{1}),2),1);
for i = 1:length(lengthDist)
    lengthDist(i) = size(rawTracks.(trackDataNames{1}){i},1);
end
shortTracks = find(lengthDist < trackSettings.minTrackLen);

for i = 1:size(trackDataNames,1)
    rawTracks.(trackDataNames{i})(shortTracks) = [];
end

%Rejigging toMappings is a bit more tricky, given the deletion of the
%tracks in the above code causes the position of tracks below them in the
%data structure to shift.
for i = shortTracks'-(0:(size(shortTracks,1)-1)) %For each short track (weird indexing here accounts for the continual subtraction of one from each track index during each run through the loop)
    %Loop through slices, deleting and reindexing if track is too short
    for j = 1:size(toMappings,1) %For each 'slice'
        currID = toMappings{j}(:,1) == i;
        bigIDs = toMappings{j}(:,1) > i;
        if sum(currID) == 1 %If this track is present at this timepoint
            toMappings{j}(currID,:) = [NaN,NaN];
        end
        toMappings{j}(bigIDs,1) = toMappings{j}(bigIDs,1) - 1;
    end
end

trackTimes(shortTracks) = [];
fromMappings(shortTracks) = [];

debugprogressbar([0.8;0.2;0],debugSet)

%Prepare smoothed position data (if needed)
if isfield(rawTracks,'Centroid')
    smoothCentroid = cell(size(rawTracks.(trackDataNames{1}),2),1);
    for i = 1:size(rawTracks.(trackDataNames{1}),2) %For every track
        smoothCentx = smooth(trackTimes{i},rawTracks.Centroid{i}(:,1),'loess',0.01);
        smoothCenty = smooth(trackTimes{i},rawTracks.Centroid{i}(:,2),'loess',0.01);
        smoothCentroid{i} = [smoothCentx,smoothCenty];
    end
end

procTracks = struct();
for i = 1:length(rawTracks.(trackDataNames{1}))
    if isfield(rawTracks,'Centroid')
        procTracks(i).x = rawTracks.Centroid{i}(:,1);
        procTracks(i).y = rawTracks.Centroid{i}(:,2);
        
        procTracks(i).smoothx = smoothCentroid{i}(:,1);
        procTracks(i).smoothy = smoothCentroid{i}(:,2);
        
        if ~exist('RawSpeed','var') || ~exist('RawTheta','var')
            [RawSpeed,RawTheta] = getAllVelocities(rawTracks.Centroid,trackTimes,trackSettings.dt);
            [SmoothSpeed,SmoothTheta] = getAllVelocities(smoothCentroid,trackTimes,trackSettings.dt);
        end
        
        procTracks(i).theta = RawTheta{i};
        procTracks(i).vmag = RawSpeed{i};
        
        procTracks(i).smoothTheta = SmoothTheta{i};
        procTracks(i).smoothVmag = SmoothSpeed{i};
    end
    if isfield(rawTracks,'Length')
        procTracks(i).majorLen = rawTracks.Length{i};
    end
    if isfield(rawTracks,'Width')
        procTracks(i).minorLen = rawTracks.Width{i};
    end
    if isfield(rawTracks,'Area')
        procTracks(i).area = rawTracks.Area{i};
    end
    if isfield(rawTracks,'Orientation')
        procTracks(i).phi = rawTracks.Orientation{i};
    end
    if isfield(rawTracks,'ChannelMean')
        for chan = 1:size(rawTracks.ChannelMean{i},2)
            fieldName = ['channel_',num2str(trackSettings.availableMeans(chan)),'_mean'];
            procTracks(i).(fieldName) = rawTracks.ChannelMean{i}(:,chan);
        end
    end
    if isfield(rawTracks,'ChannelStd')
        for chan = 1:size(rawTracks.ChannelStd{i},2)
            fieldName = ['channel_',num2str(trackSettings.availableStds(chan)),'_std'];
            procTracks(i).(fieldName) = rawTracks.ChannelStd{i}(:,chan);
        end
    end
    if isfield(rawTracks,'SpareFeat1')
        procTracks(i).sparefeat1 = rawTracks.SpareFeat1{i};
    end
    if isfield(rawTracks,'SpareFeat2')
        procTracks(i).sparefeat2 = rawTracks.SpareFeat2{i};
    end
    if isfield(rawTracks,'SpareFeat3')
        procTracks(i).sparefeat3 = rawTracks.SpareFeat3{i};
    end
    if isfield(rawTracks,'SpareFeat4')
        procTracks(i).sparefeat4 = rawTracks.SpareFeat4{i};
    end
    procTracks(i).times = trackTimes{i};
    procTracks(i).length = size(trackTimes{i},2);
    procTracks(i).start = trackTimes{i}(1);
    procTracks(i).end = trackTimes{i}(end);
    
    debugprogressbar([0.8;(i*0.8)/length(rawTracks.(trackDataNames{1})) + 0.2;0],debugSet)
end

%Insert an 'age' field, indicating the age of the object (time from start
%of track)
for i = 1:size(procTracks,2)
    procTracks(i).age = (procTracks(i).times - procTracks(i).times(1))'*trackSettings.dt;
end